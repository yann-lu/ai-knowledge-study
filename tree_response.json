{"categories":[{"knowledgeSet":[{"id":1,"title":"一口气讲明白分布式锁","content":"#### **1. 什么是锁？锁有什么特点？**\n- **问题**：锁的作用是什么？它的特点是什么？\n- **答案**：锁是一种用来控制多个线程或多个进程访问共享资源的机制。锁的主要特点是**互斥性**，即一个线程拿到锁后，其他线程无法获取锁，从而保证资源的安全访问。\n#### **2. Redis 的 setnx 命令如何实现互斥性？为什么它能保证原子性？**\n- **问题**：Redis 的 setnx 命令是如何实现互斥性的？为什么它不需要放到 Lua 脚本里？\n- **答案**：`setnx` 命令可以保证只有一个线程能成功设置值，从而实现互斥。Redis 是单线程模型，单个命令的执行天然是原子性的，因此不需要额外的 Lua 脚本来保证原子性。\n#### 3. **如果线程挂了，锁无法释放怎么办？**\n\n- **问题**：线程挂了之后锁无法释放，这会导致什么问题？如何解决？\n- **答案**：线程挂了后锁无法释放，会导致死锁问题。可以给锁设置一个**过期时间**，即使线程挂了，锁也能自动释放。\n\n#### **4. 锁设置了过期时间，但线程业务还没执行完，锁过期了怎么办？**\n\n- **问题**：锁的过期时间到了，但线程还在执行任务，会发生什么问题？如何解决？\n- **答案**：锁过期后，其他线程可能会抢到锁，导致资源竞争。可以使用**看门狗机制**，定时给锁续期，确保锁在业务执行期间不会过期。\n\n#### **5. 看门狗线程会一直续期，但如果业务线程挂了怎么办？**\n\n- **问题**：业务线程挂了，看门狗线程会一直续期，这样锁就无法释放了，如何解决？\n- **答案**：可以将看门狗线程设置为**守护线程**，守护线程的生命周期依赖于业务线程。如果业务线程挂了，守护线程会自动终止，从而停止续期。\n\n#### **6. 分布式锁如何实现可重入性？**\n\n- **问题**：如何设计分布式锁，使得同一个线程可以多次获取同一个锁（可重入锁）？\n- **答案**：可以使用锁计数器来实现可重入：\n\n  - 方案1：使用 Redis 的哈希结构，`key` 是锁对象，`field` 是线程ID拼UUID，`value` 是计数器。\n\n    - 为什么要用线程id拼uuid作为field呢？因为在集群环境下，线程id有可能是重复的，所以要拼接uuid保证唯一性\n  - 方案2：使用 Redis 的 String 结构，服务端维护一个 `ConcurrentHashMap`，`value` 是计数器。\n  - 计数器记录线程重入次数，释放锁时计数器减到0再释放锁。\n\n#### **7. 分布式锁如何实现阻塞锁？**\n\n- **问题**：线程没有抢到锁时，需要等待一会儿再重新抢锁，如何设计阻塞锁？\n- **答案**：可以使用两种方式：\n\n  - 方式1：**自旋**：线程不断尝试获取锁，一旦锁释放就能继续执行。\n  - 方式2：**发布订阅**：没抢到锁的线程订阅锁释放事件，抢到锁的线程释放锁后发布消息唤醒订阅线程\n\n#### **8. Redis 主从架构下，锁可能会丢失，为什么？**\n\n- **问题**：Redis 是主从架构时，锁可能会丢失，具体是什么原因？\n- **答案**：当锁写入到主节点后，主节点还未同步到从节点就挂了，新主节点没有锁的数据，导致锁丢失问题。\n\n#### **9. 如何解决 Redis 主从架构下的锁丢失问题？**\n\n- **问题**：Redis 主从架构下锁丢失问题怎么解决？\n- **答案**：\n\n  - **联锁机制**：Redis 部署多主或多主多从，加锁时必须所有主节点都成功加锁才算加锁成功。\n  - **红锁机制**：Redis 部署多个主节点，只需要半数以上节点加锁成功即可。\n#### **10. 联锁机制的缺点是什么？如何优化？**\n- **问题**：联锁机制有哪些问题？如何优化？\n- **答案**：联锁机制可能因为某个主节点网络延迟或宕机导致加锁失败，整体加锁成功率较低。可以优化为**红锁机制**，只需半数以上节点加锁成功即可。\n\n#### **11. 红锁机制有什么问题？为什么不常用？**\n\n- **问题**：红锁机制有哪些问题？为什么在实际中不常用？\n- **答案**：\n\n  - **问题**：\n\n    - 不同节点的系统时钟可能不一致，导致时间严格要求出现问题。\n    - GC暂停线程会导致看门狗无法续期，锁过期。\n    - 多主节点的运维复杂，数据一致性难以保证。\n  - **原因**：红锁机制虽然理论上很强，但实现复杂，且运维成本高，实际中并不常用。\n\n#### **12. 分布式锁的实现方案有哪些？**\n\n- **问题**：分布式锁的实现方案有哪些？哪些方案更常用？\n- **答案**：\n\n  - 自己实现简单的分布式锁（如基于 `setnx`）。\n  - 使用成熟的库，如 **Redisson**。\n  - 红锁机制（少用）。","outline":"- **锁的定义与特点**  \n- **Redis setnx 实现互斥**  \n- **锁无法释放的解决方案**  \n- **锁过期问题与看门狗机制**  \n- **看门狗线程与业务线程关系**  \n- **分布式锁的可重入性实现**  \n- **分布式锁的阻塞机制**  \n- **Redis 主从架构下的锁丢失**  \n- **解决主从锁丢失的方法**  \n- **联锁与红锁机制对比**  \n- **红锁机制的问题与局限**  \n- **常见分布式锁实现方案**","categories":[{"id":5,"name":"Redis","level":1,"sortOrder":0,"createTime":"2025-07-11T23:57:15.075663","updateTime":"2025-07-11T23:57:15.075686","fullPath":"Redis","topLevel":true},{"id":6,"name":"分布式锁","level":2,"sortOrder":0,"createTime":"2025-07-11T23:57:23.999653","updateTime":"2025-07-11T23:57:23.999661","fullPath":"Redis > 分布式锁","topLevel":false}],"createdAt":"2025-07-06T22:53:00.656901","updatedAt":"2025-07-12T23:16:38.099542"},{"id":2,"title":"Redisson（一）","content":"![image.png](https://image-1322336011.cos.ap-shanghai.myqcloud.com/20231118210633.png)\n\n# 1. 加锁和解锁\n- **Lua脚本保证原子性**：加锁和解锁均通过Lua脚本实现，确保操作（检查锁存在性、更新计数器、设置超时）的原子性。\n  - **加锁脚本**：检查锁是否存在，不存在则创建并设置超时；存在则验证是否为当前线程持有，是则重入。\n  - **解锁脚本**：校验锁归属，计数器减1后若归零则删除锁，并发布解锁消息。\n\n## 为什么要用lua脚本呢？\n```lua\nif ((redis.call('exists', KEYS[1]) == 0) \n    or (redis.call('hexists', KEYS[1], ARGV[2]) == 1)) then \n    redis.call('hincrby', KEYS[1], ARGV[2], 1); \n    redis.call('pexpire', KEYS[1], ARGV[1]); \n    return nil; \nend; \nreturn redis.call('pttl', KEYS[1]);\n```\n这个 Lua 脚本实现了以下逻辑：\n1. **检查锁是否已存在**：\n    - 如果锁不存在（`exists KEYS[1] == 0`），或者锁已存在且是当前线程持有（`hexists KEYS[1], ARGV[2] == 1`），则执行加锁。\n2. **加锁操作**：\n    - 增加锁的重入次数：`hincrby KEYS[1], ARGV[2], 1`。\n    - 设置锁的过期时间：`pexpire KEYS[1], ARGV[1]`。\n3. **返回锁的剩余 TTL**：\n    - 如果锁未被当前线程持有，返回锁的剩余时间（TTL），以便客户端知道需要等待多长时间。\n\n**为什么用 Lua 脚本加锁？**\n- **支持可重入锁**：Lua 脚本可以直接操作 Redis 的 `Hash` 数据结构，允许同一个线程多次获取同一个锁。\n- **原子性**：Lua 脚本在 Redis 服务端一次性执行，避免了多个命令之间的竞争条件问题。\n- **扩展性**：可以轻松添加其他逻辑，比如记录锁的持有线程、设置锁的自动续期等。\n\n## 扩展问题：为什么lua脚本可以保证原子性？\n![image.png](https://image-1322336011.cos.ap-shanghai.myqcloud.com/202312162239786.png)\n\n# 2. Watch Dog自动延期机制（看门狗机制）\n**自动续期防止锁超时**：若未显式指定锁超时时间（如`lock.lock()`），Redisson默认启动看门狗线程，每10秒（默认）续期锁至30秒，避免业务未完成时锁超时释放\n\n# 3. 可重入加锁机制\n#### **可重入锁机制**\n- **Hash结构存储锁信息**：Redisson使用Redis的Hash结构存储锁，Key为锁名称（如`xxl:job:时间戳`），Field为客户端唯一标识（`UUID + 线程ID`），Value为重入计数器。\n  - **示例**：同一线程多次调用`lock()`时，计数器自增；`unlock()`时计数器自减，归零后删除锁\n  - **代码优化建议**：若业务存在嵌套锁场景（如递归调用），需确保`lock()`和`unlock()`成对出现。\n\n# 4. **锁竞争与重试机制**\n- **发布订阅模式**：当锁被其他线程持有时，当前线程订阅解锁消息通道，避免轮询消耗资源；收到解锁通知后重新竞争锁\n  - **可重试逻辑**：通过`tryLock()`方法支持设置最大等待时间（`waitTime`），实现阻塞式或非阻塞式重试\n\n# 5. Redisson实现公平锁\n\n1. **什么是公平锁？**\n\n    保证等待最久的线程最先获取锁\n\n2. **Redisson的公平锁是如何实现的？**\n\n（1）Redisson的公平锁是通过有序集合（zset）实现的。每个锁都对应一个有序集合(zset)，集合中的成员是等待锁的线程，分数是线程的等待时间戳。获取锁时，Redisson会将线程添加到有序集合中，并按照时间戳排序。（当前线程如果不是在最前面，则需要等待），排在zset最前面的线程获取到锁\n\n（3）当释放锁时，Redisson 会从有序集合中移除当前线程的标识，并通过 publish 通知其他线程锁已释放。等待时间最长的线程会在接收到通知后重新尝试获取锁(检查自己是否是zset的第一个成员，如果是，则获取锁；如果不是，则继续等待)，从而实现公平性。\n\n3. **是怎么通知其他线程的？**\n\n    使用的Redis的publish命令，也就是发布订阅的能力（`publish` 命令会将消息广播给所有订阅了该频道的客户端）\n\n```lua\nredis.call('publish', KEYS[2], ARGV[2]);\nKEYS[2] 是锁对应的频道名称。\nARGV[2] 是通知的内容，通常是一个简单的消息，表明锁已释放。\n```","outline":"**知识要点提示大纲**\n\n1. **加锁与解锁机制**  \n   - Lua脚本实现原子性  \n   - 加锁逻辑与重入处理  \n   - 解锁验证与消息通知  \n\n2. **Lua脚本优势**  \n   - 可重入支持  \n   - 原子性保障  \n   - 扩展性强  \n\n3. **看门狗自动延期**  \n   - 自动续期机制  \n   - 防止锁过早释放  \n\n4. **可重入锁实现**  \n   - Hash结构存储信息  \n   - 重入计数器管理  \n   - 成对调用建议  \n\n5. **锁竞争与重试**  \n   - 发布订阅避免轮询  \n   - tryLock重试逻辑  \n\n6. **公平锁实现**  \n   - 有序集合（zset）管理等待队列  \n   - 获取锁顺序控制  \n   - 释放锁后通知机制","categories":[{"id":5,"name":"Redis","level":1,"sortOrder":0,"createTime":"2025-07-11T23:57:15.075663","updateTime":"2025-07-11T23:57:15.075686","fullPath":"Redis","topLevel":true},{"id":6,"name":"分布式锁","level":2,"sortOrder":0,"createTime":"2025-07-11T23:57:23.999653","updateTime":"2025-07-11T23:57:23.999661","fullPath":"Redis > 分布式锁","topLevel":false}],"createdAt":"2025-07-08T23:00:39.224842","updatedAt":"2025-07-12T23:16:22.582084"},{"id":4,"title":"Redisson（二）","content":"# 4. **锁竞争与重试机制**\n\n`lock()方法`：（无返回值）`lock()` 方法是阻塞获取锁的方式，如果当前锁被其他线程持有，则当前线程会一直阻塞等待获取锁，直到获取到锁或者发生超时或中断等情况才会结束等待\n\n```java\nlock.lock()  // 阻塞时获取锁\nlock.lock(30, TimeUnit.SECONDS); // 尝试获取锁，30秒后自动释放\n```\n\n\n\n## 非阻塞获取锁\n\n`tryLock()方法`：（有返回值）`tryLock()` 方法是一种非阻塞获取锁的方式，在尝试获取锁时不会阻塞当前线程，而是立即返回获取锁的结果，如果获取成功则返回 true，否则返回 false（可以设置 **等待时间**（`waitTime`）和 **锁持有时间**（`leaseTime`），灵活控制锁的获取和持有行为）\n\n```java\n// 不阻塞，立即获取结果\nboolean success = lock.tryLock()\n\n// 尝试获取锁，等待最多 5 秒，成功后持有锁 10 秒\nboolean success = lock.tryLock(5, 10, TimeUnit.SECONDS);\n```\n\n## 发布订阅模式\n\n**锁释放后的竞争**：\n\n- 当锁被释放时，Redisson 会通知等待队列中的线程。\n- 如果是公平锁（`RedissonFairLock`），线程会按照队列顺序竞争锁。\n- 如果是普通锁（`RedissonLock`），竞争顺序可能不是严格的 FIFO（先到先得）。\n\n是如何通知的？\n\n- 使用的Redis的publish命令，也就是发布订阅的能力（`publish` 命令会将消息广播给所有订阅了该频道的客户端，收到解锁通知后重新竞争锁）\n\n\n# 5. Redisson实现公平锁\n\n1. **什么是公平锁？**\n\n    保证等待最久的线程最先获取锁\n\n2. **Redisson的公平锁是如何实现的？**\n\n（1）Redisson的公平锁是通过有序集合（zset）实现的。每个锁都对应一个有序集合(zset)，集合中的成员是等待锁的线程，分数是线程的等待时间戳。获取锁时，Redisson会将线程添加到有序集合中，并按照时间戳排序。（当前线程如果不是在最前面，则需要等待），排在zset最前面的线程获取到锁\n\n（3）当释放锁时，Redisson 会从有序集合中移除当前线程的标识，并通过 publish 通知其他线程锁已释放。等待时间最长的线程会在接收到通知后重新尝试获取锁(检查自己是否是zset的第一个成员，如果是，则获取锁；如果不是，则继续等待)，从而实现公平性。\n\n3. **是怎么通知其他线程的？**\n\n    使用的Redis的publish命令，也就是发布订阅的能力（`publish` 命令会将消息广播给所有订阅了该频道的客户端）\n\n```lua\nredis.call('publish', KEYS[2], ARGV[2]);\nKEYS[2] 是锁对应的频道名称。\nARGV[2] 是通知的内容，通常是一个简单的消息，表明锁已释放。\n```","outline":"**知识要点提示大纲**\n\n- **锁竞争与重试机制**\n  - lock() 方法\n  - tryLock() 方法\n  - 非阻塞获取锁\n  - 等待时间与持有时间设置\n\n- **发布订阅模式**\n  - 锁释放后的竞争机制\n  - 公平锁与普通锁的区别\n  - Redis 的 publish 命令作用\n\n- **Redisson 公平锁实现**\n  - 公平锁定义\n  - zset 数据结构应用\n  - 获取锁流程\n  - 释放锁流程\n  - Redis 发布订阅通知机制","categories":[{"id":5,"name":"Redis","level":1,"sortOrder":0,"createTime":"2025-07-11T23:57:15.075663","updateTime":"2025-07-11T23:57:15.075686","fullPath":"Redis","topLevel":true},{"id":6,"name":"分布式锁","level":2,"sortOrder":0,"createTime":"2025-07-11T23:57:23.999653","updateTime":"2025-07-11T23:57:23.999661","fullPath":"Redis > 分布式锁","topLevel":false}],"createdAt":"2025-07-11T23:14:53.785471","updatedAt":"2025-07-12T23:16:10.492789"},{"id":10,"title":"Redisson（三）","content":"# 6. Redisson的联锁\n\n## 6.1. 什么是联锁？\n\n    支持同时获取多个锁，防止死锁\n\n## 6.2. 代码\n\n    ```java\n    RLock lock1 = redisson.getLock(\"lock1\");\n    RLock lock2 = redisson.getLock(\"lock2\");\n    RLock lock3 = redisson.getLock(\"lock3\");\n    // 创建联锁\n    RLock multiLock = redisson.getMultiLock(lock1, lock2, lock3);\n    // 加锁\n    multiLock.lock();  或者  multiLock.tryLock(10, 30, TimeUnit.SECONDS);（添加超时时间）\n\n    try {\n        // 执行需要同时锁定多个资源的操作\n        System.out.println(\"所有锁已成功获取\");\n    } finally {\n        // 释放锁\n        multiLock.unlock();\n    }\n    ```\n\n## 6.3. 使用场景\n\n    1. 订单和库存的联合操作\n\n        > 在电商系统中，创建订单时需要同时锁定订单记录和库存记录，以防止其他线程或服务修改数据。例如：\n        >\n        > - 线程 A 锁定订单 `order:123` 和库存 `stock:456`。\n        > - 线程 B 锁定订单 `order:124` 和库存 `stock:456`。 通过联锁，可以确保操作的原子性，避免死锁。\n        >\n\n## 6.4. 避免死锁的机制\n\n    1. **统一获取所有锁**：\n\n        - 只有当所有锁都成功获取时，线程才会持有联锁。\n        - 如果某个锁获取失败，会自动释放之前已获取的锁。\n    2. **严格的加锁顺序**：\n\n        - 联锁内部会按照一定的顺序尝试获取锁，确保多个线程在获取相同资源时遵循相同的顺序，从而避免死锁。\n    3. **超时机制**：\n\n        - 联锁支持设置获取锁的超时时间。如果线程无法在指定时间内获取所有锁，会主动放弃并释放已获取的锁。\n\n## 6.5. 联锁机制的问题\n联锁机制可能因为某个主节点网络延迟或宕机导致加锁失败，整体加锁成功率较低。解决方案是：可以优化为红锁机制，只需半数以上节点加锁成功即可\n\n\n# 7. 红锁\n\n## 7.1 红锁的实现\n\n我们使用RRedLock来创建一个红锁对象，然后使用redLock.tryLock()来尝试获取锁。如果大多数节点成功获取锁，就会执行锁保护的代码。\n\n```java\nRLock lock1 = redisson.getLock(\"lock1\");\nRLock lock2 = redisson.getLock(\"lock2\");\nRLock lock3 = redisson.getLock(\"lock3\");\nRLock redLock = redisson.getRedLock(lock1, lock2, lock3);\nboolean isLocked = redLock.tryLock(100, 60, TimeUnit.SECONDS);\n```\n\n\n## 7.2 Redisson红锁解决了什么问题\n\n- 红锁设计的初衷是解决**单点 Redis 实例锁不可靠的问题**，尤其是在 Redis 主从复制延迟或故障时，传统锁可能失效，导致并发控制失败。\n- Redisson 红锁通过**多个 Redis 实例获取多数节点锁**，提高了锁的可靠性和容错性。\n\n\n## 7.3 Redisson红锁的问题：\n\n**问题一：时间同步问题**\n\n> 客户端在每个 Redis 实例上设置锁时，会指定一个统一的超时时间。如果 Redis 实例的时间不一致（如某个节点的时间快或慢），可能导致某些节点上的锁比预期时间提前过期、某些节点上的锁比预期时间晚过期。（如果提前释放锁，可能导致其他客户端错误获取锁，引起并发问题；如果晚释放，导致新客户端无法获取锁，影响系统的性能和可用性）\n\n```java\n举例：\n假设有 3 个 Redis 节点，客户端在每个节点上设置锁的超时时间为 10 秒：\n\nRedis 节点 A 的时间比真实时间快 2 秒。\nRedis 节点 B 的时间是正确的。\nRedis 节点 C 的时间比真实时间慢 3 秒。\n锁的行为可能如下：\n\n节点 A 在 8 秒后认为锁已经过期。\n节点 B 在 10 秒后认为锁已经过期。\n节点 C 在 13 秒后认为锁才过期。\n```\n\n解决方案：\n\n1. **时间同步机制**\n\n    - 使用 NTP（Network Time Protocol，网络时间协议）对所有 Redis 实例的时间进行同步，确保每个节点的时间保持一致。\n    - 定期检查和修复时间偏差，避免时间漂移。\n2. **相对时间代替绝对时间**\n\n    - 在实现分布式锁时，尽量使用相对时间（如锁的存活时间计时从当前时刻开始）而不是依赖绝对时间。\n    - Redisson 内部通过 Redis 的 `PEXPIRE` 命令设置锁的超时时间，使用的是相对时间，因此在一定程度上缓解了时间同步问题。\n3. **增加锁的冗余机制**\n\n    - 即使时间同步出现问题，可以通过增加锁的数量（更多的 Redis 节点）来提高容错性。\n\n\n扩展问题：\n\n> Redisson 在加锁时将你传入的 `leaseTime`（如 10 秒）转换为毫秒数（10,000），作为相对时间参数传给 Redis 的 `PEXPIRE` 命令。这个时间是**从 Redis 当前时刻算起**的，所以即便系统时间不同步，也能保证各节点锁超时逻辑一致。\n\n\t\n\n问题二：**网络分区导致的一致性问题**\n\n在网络分区的情况下，可能会出现多个客户端在不同的网络分区中同时获得锁，从而破坏锁的互斥性，导致数据一致性问题。\n\n1. **锁的双重获取**\n\n    - 假设有 5 个 Redis 节点，其中 3 个节点属于网络分区 A，另 2 个节点属于网络分区 B。\n    - 如果客户端 1 在分区 A 中获取了锁，并在 A 的 3 个节点上成功加锁；\n    - 同时，客户端 2 在分区 B 中也可以获取锁，因为 B 中的 2 个节点与 A 中的节点无法通信，客户端 2 无法感知锁的存在。\n    - 结果：客户端 1 和客户端 2 都认为自己获取了锁，导致锁的互斥性被破坏。\n2. **锁释放的不一致**\n\n    - 如果客户端在某些节点上成功加锁，但在锁释放时，由于网络分区，无法释放其他节点上的锁，导致锁的状态不一致。\n    - 其他客户端可能无法正确获取锁，影响系统的可用性。\n\n#### **示例**\n\n假设有 5 个 Redis 节点，客户端 1 和客户端 2 试图同时获取锁：\n\n- 正常情况下：\n\n  - 客户端 1 在 3 个节点上成功加锁（多数派），锁获取成功。\n  - 客户端 2 加锁失败。\n- 网络分区情况下：\n\n  - 分区 A：包含 3 个节点，客户端 1 在分区 A 上成功加锁。\n  - 分区 B：包含 2 个节点，客户端 2 在分区 B 上也成功加锁。\n  - 结果：客户端 1 和客户端 2 都认为自己持有锁，导致数据一致性问题。\n\n### **解决方法**\n\n- **减少网络分区**：通过优化网络基础设施，减少分区发生的概率。\n- **使用一致性协议**：红锁并不保证严格一致性。如果业务对一致性要求极高，考虑使用基于共识协议（如 Paxos、Raft）的锁机制，如 ZooKeeper 或 etcd。\n- **多层锁保护机制**：在本地 JVM 或数据库层再加一层锁，形成“防护网”\n\n\n# 8. 读写锁\n\nRedisson支持读写锁，允许**多个线程同时读取共享资源，但只允许一个线程写入资源**。这在某些场景下可以提高性能\n\n使用RReadWriteLock来创建一个读写锁对象，并分别使用readLock和writeLock来获取读锁和写锁。这样，可以实现多个线程同时读取资源，但只有一个线程能够写入资源\n\n```java\nRReadWriteLock rwLock = redisson.getReadWriteLock(\"myReadWriteLock\");\nRLock readLock = rwLock.readLock();\nRLock writeLock = rwLock.writeLock();\n\n// 获取读锁\nreadLock.lock();\ntry {\n    // 执行读操作\n} finally {\n    readLock.unlock();\n}\n\n// 获取写锁\nwriteLock.lock();\ntry {\n    // 执行写操作\n} finally {\n    writeLock.unlock();\n}\n```","outline":"### 知识要点提示大纲（简洁版）\n\n- **6. Redisson 联锁**\n  - 联锁定义\n  - 联锁代码实现\n  - 使用场景\n  - 避免死锁机制\n  - 联锁问题与优化\n\n- **7. 红锁**\n  - 红锁实现方式\n  - 红锁解决的问题\n  - 红锁存在的问题\n  - 时间同步问题\n  - 网络分区问题\n  - 解决方案\n\n- **8. 读写锁**\n  - 读写锁功能\n  - 读锁与写锁使用\n  - 读写锁代码示例","categories":[{"id":5,"name":"Redis","level":1,"sortOrder":0,"createTime":"2025-07-11T23:57:15.075663","updateTime":"2025-07-11T23:57:15.075686","fullPath":"Redis","topLevel":true},{"id":6,"name":"分布式锁","level":2,"sortOrder":0,"createTime":"2025-07-11T23:57:23.999653","updateTime":"2025-07-11T23:57:23.999661","fullPath":"Redis > 分布式锁","topLevel":false}],"createdAt":"2025-07-12T08:43:08.040932","updatedAt":"2025-07-12T23:15:59.775871"},{"id":12,"title":"Redis主从同步锁丢失问题","content":"# 1. 主从同步-锁丢失问题\n问题1：redis主从架构时，主节点写入了一个分布式锁，再同步到从节点的时候发生了故障，导致这个分布式锁未成功同步到从节点，这个时候从节点被选举为主节点，分布式锁的业务还未执行完毕，这个时候另一个线程就可以获取到锁，这样就导致业务被并发执行了，如何解决这个问题？\n\n问题2：Redis 主从架构下锁丢失问题怎么解决？\n\n以上两个问题类似，答案是可以使用联锁或者红锁（但都有各自的问题），或者使用zookeeper、etcd\n\n- 联锁机制：Redis 部署多主或多主多从，加锁时必须所有主节点都成功加锁才算加锁成功。\n- 红锁机制：Redis 部署多个主节点，只需要半数以上节点加锁成功即可。\n\n## 1.1 联锁的问题\n联锁机制可能因为某个主节点网络延迟或宕机导致加锁失败，整体加锁成功率较低。可以优化为红锁机制，只需半数以上节点加锁成功即可。\n\n## 1.2 红锁的问题\n（1）时间同步问题，不同节点的系统时钟可能不一致，导致时间严格要求出现问题。\n（2）并发安全性问题：当客户端加锁时，如果遇到 GC 可能会导致加锁失效，但 GC 后误认为加锁成功的安全事故\n（3）多主节点的运维复杂，数据一致性难以保证。\n原因：红锁机制虽然理论上很强，但实现复杂，且运维成本高，实际中并不常用。\n\n### 1.2.1 GC暂停线程导致加锁的事故问题（这点举个例子）\n 1. 客户端 A 请求 3 个节点进行加锁。\n 2. 在节点回复处理之前，客户端 A 进入 GC 阶段（存在 STW，全局停顿）。\n 3. 之后因为加锁时间的原因，锁已经失效了。\n 4. 客户端 B 请求加锁（和客户端 A 是同一把锁），加锁成功。\n 5. 客户端 A GC 完成，继续处理前面节点的消息，误以为加锁成功。\n 6. 此时客户端 B 和客户端 A 同时加锁成功，出现并发安全性问题。\n\n### 1.2.2 时钟同步问题举个例子（网络问题）\n![](https://image-1322336011.cos.ap-shanghai.myqcloud.com/202507122257322.png)\n\n### 1.2.3 关于网络问题可以再举个例子（网络分区问题）\n![](https://image-1322336011.cos.ap-shanghai.myqcloud.com/202507122258595.png)","outline":"### 知识要点大纲（提示回忆用）\n\n- **主从同步-锁丢失问题**\n  - 联锁机制\n  - 红锁机制\n  - 其他方案：ZooKeeper、etcd\n\n- **联锁的问题**\n  - 加锁成功率低\n  - 网络或节点故障影响整体加锁\n\n- **红锁的问题**\n  - 时间同步问题\n  - GC 导致加锁失效风险\n  - 多主节点运维复杂\n  - 数据一致性难保证\n\n- **红锁事故案例**\n  - GC 暂停导致误加锁\n  - 时钟不同步引发问题\n  - 网络分区影响加锁过程","categories":[{"id":5,"name":"Redis","level":1,"sortOrder":0,"createTime":"2025-07-11T23:57:15.075663","updateTime":"2025-07-11T23:57:15.075686","fullPath":"Redis","topLevel":true},{"id":6,"name":"分布式锁","level":2,"sortOrder":0,"createTime":"2025-07-11T23:57:23.999653","updateTime":"2025-07-11T23:57:23.999661","fullPath":"Redis > 分布式锁","topLevel":false}],"createdAt":"2025-07-12T22:53:26.744631","updatedAt":"2025-07-12T23:13:15.037089"},{"id":13,"title":"主从复制","content":"# 1. 主从复制的断点续传（增量复制）\n\n- 什么是断点续传：从redis2.8开始，就支持主从复制的断点续传，如果主从复制的过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头复制\n- 核心原理：master node会在内存中保存一个backlog。master和slave都会保存一个replica offset和master id，offset就是保存在backlog中。如果master和slave网络连接断掉了，slave会让master从上次的replica offset开始复制，但是如果没有找到对应的offset,就会执行一次resynchronization\n\n# 2. slave节点过期key是如何处理的\n\nslave不会过期key,只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key,那么会模拟一条del命令发送给slave\n\n# 3. 心跳机制\n\n在Redis主从复制架构中，Redis使用心跳机制来检测主节点和从节点之间的连接状态。这个心跳机制主要包括两个方面：PING命令和复制偏移量。\n\n1. PING命令：主节点会周期性地向从节点发送PING命令，以确认从节点是否在线。从节点收到PING命令后会回复一个PONG响应，表示自己仍然存活。如果主节点在一定时间内没有收到从节点的PONG响应，就会认为从节点宕机或者与从节点的连接出现问题。\n2. 复制积压缓冲区（replication backlog）：主节点会将自己的数据更新发送给从节点，并存储在复制积压缓冲区中。从节点会定期向主节点报告自己的复制偏移量，主节点通过比较从节点的复制偏移量和自己的复制偏移量来判断从节点是否与主节点保持同步。如果从节点的复制偏移量长时间没有更新，主节点会认为从节点与自己的连接出现问题。\n\n## 3.1 扩展：如果通过心跳机制发现了从节点的不可用，主节点会做什么呢？\n\n当主节点通过心跳机制发现从节点可能出现了不可用的情况时，它可以采取以下几种措施：\n\n1. 重新选择从节点：如果主节点发现当前的从节点不可用，它可以重新选择一个可用的从节点来替代它。主节点会从备选的从节点列表中选择一个新的从节点，并将其设置为新的复制目标。这样可以确保主节点始终有可用的从节点进行数据复制和故障恢复。\n2. 进行故障恢复：如果主节点发现从节点不可用，并且没有其他可用的从节点可以替代，它可以尝试进行故障恢复。故障恢复的过程包括重新同步数据和重新选举主节点。\n\n    - 重新同步数据：主节点可以将自己的数据重新发送给从节点，使其与主节点的数据保持一致。这可以通过将复制积压缓冲区中的数据重新发送给从节点来实现。重新同步数据可能会导致一定的网络和系统负载，因此需要谨慎使用。\n    - 重新选举主节点：如果主节点发现从节点不可用，并且没有其他可用的从节点可以替代，它可以尝试进行重新选举主节点的过程。重新选举主节点需要从备选的从节点中选择一个新的主节点，并进行相应的配置和数据同步操作。\n\n# 4. 主从复制的核心原理\n\n![image.png](https://image-1322336011.cos.ap-shanghai.myqcloud.com/202312162244342.png)","outline":"- 1. 主从复制的断点续传  \n- 2. Slave节点过期Key处理  \n- 3. 心跳机制与故障应对  \n- 4. 主从复制核心原理","categories":[{"id":5,"name":"Redis","level":1,"sortOrder":0,"createTime":"2025-07-11T23:57:15.075663","updateTime":"2025-07-11T23:57:15.075686","fullPath":"Redis","topLevel":true},{"id":13,"name":"架构","level":1,"sortOrder":0,"createTime":"2025-07-12T22:19:08.628868","updateTime":"2025-07-12T22:19:08.628872","fullPath":"Redis > 架构","topLevel":false}],"createdAt":"2025-07-12T23:07:25.063231","updatedAt":"2025-07-12T23:07:25.06324"}],"level":1,"children":[{"knowledgeSet":[{"id":1,"title":"一口气讲明白分布式锁","content":"#### **1. 什么是锁？锁有什么特点？**\n- **问题**：锁的作用是什么？它的特点是什么？\n- **答案**：锁是一种用来控制多个线程或多个进程访问共享资源的机制。锁的主要特点是**互斥性**，即一个线程拿到锁后，其他线程无法获取锁，从而保证资源的安全访问。\n#### **2. Redis 的 setnx 命令如何实现互斥性？为什么它能保证原子性？**\n- **问题**：Redis 的 setnx 命令是如何实现互斥性的？为什么它不需要放到 Lua 脚本里？\n- **答案**：`setnx` 命令可以保证只有一个线程能成功设置值，从而实现互斥。Redis 是单线程模型，单个命令的执行天然是原子性的，因此不需要额外的 Lua 脚本来保证原子性。\n#### 3. **如果线程挂了，锁无法释放怎么办？**\n\n- **问题**：线程挂了之后锁无法释放，这会导致什么问题？如何解决？\n- **答案**：线程挂了后锁无法释放，会导致死锁问题。可以给锁设置一个**过期时间**，即使线程挂了，锁也能自动释放。\n\n#### **4. 锁设置了过期时间，但线程业务还没执行完，锁过期了怎么办？**\n\n- **问题**：锁的过期时间到了，但线程还在执行任务，会发生什么问题？如何解决？\n- **答案**：锁过期后，其他线程可能会抢到锁，导致资源竞争。可以使用**看门狗机制**，定时给锁续期，确保锁在业务执行期间不会过期。\n\n#### **5. 看门狗线程会一直续期，但如果业务线程挂了怎么办？**\n\n- **问题**：业务线程挂了，看门狗线程会一直续期，这样锁就无法释放了，如何解决？\n- **答案**：可以将看门狗线程设置为**守护线程**，守护线程的生命周期依赖于业务线程。如果业务线程挂了，守护线程会自动终止，从而停止续期。\n\n#### **6. 分布式锁如何实现可重入性？**\n\n- **问题**：如何设计分布式锁，使得同一个线程可以多次获取同一个锁（可重入锁）？\n- **答案**：可以使用锁计数器来实现可重入：\n\n  - 方案1：使用 Redis 的哈希结构，`key` 是锁对象，`field` 是线程ID拼UUID，`value` 是计数器。\n\n    - 为什么要用线程id拼uuid作为field呢？因为在集群环境下，线程id有可能是重复的，所以要拼接uuid保证唯一性\n  - 方案2：使用 Redis 的 String 结构，服务端维护一个 `ConcurrentHashMap`，`value` 是计数器。\n  - 计数器记录线程重入次数，释放锁时计数器减到0再释放锁。\n\n#### **7. 分布式锁如何实现阻塞锁？**\n\n- **问题**：线程没有抢到锁时，需要等待一会儿再重新抢锁，如何设计阻塞锁？\n- **答案**：可以使用两种方式：\n\n  - 方式1：**自旋**：线程不断尝试获取锁，一旦锁释放就能继续执行。\n  - 方式2：**发布订阅**：没抢到锁的线程订阅锁释放事件，抢到锁的线程释放锁后发布消息唤醒订阅线程\n\n#### **8. Redis 主从架构下，锁可能会丢失，为什么？**\n\n- **问题**：Redis 是主从架构时，锁可能会丢失，具体是什么原因？\n- **答案**：当锁写入到主节点后，主节点还未同步到从节点就挂了，新主节点没有锁的数据，导致锁丢失问题。\n\n#### **9. 如何解决 Redis 主从架构下的锁丢失问题？**\n\n- **问题**：Redis 主从架构下锁丢失问题怎么解决？\n- **答案**：\n\n  - **联锁机制**：Redis 部署多主或多主多从，加锁时必须所有主节点都成功加锁才算加锁成功。\n  - **红锁机制**：Redis 部署多个主节点，只需要半数以上节点加锁成功即可。\n#### **10. 联锁机制的缺点是什么？如何优化？**\n- **问题**：联锁机制有哪些问题？如何优化？\n- **答案**：联锁机制可能因为某个主节点网络延迟或宕机导致加锁失败，整体加锁成功率较低。可以优化为**红锁机制**，只需半数以上节点加锁成功即可。\n\n#### **11. 红锁机制有什么问题？为什么不常用？**\n\n- **问题**：红锁机制有哪些问题？为什么在实际中不常用？\n- **答案**：\n\n  - **问题**：\n\n    - 不同节点的系统时钟可能不一致，导致时间严格要求出现问题。\n    - GC暂停线程会导致看门狗无法续期，锁过期。\n    - 多主节点的运维复杂，数据一致性难以保证。\n  - **原因**：红锁机制虽然理论上很强，但实现复杂，且运维成本高，实际中并不常用。\n\n#### **12. 分布式锁的实现方案有哪些？**\n\n- **问题**：分布式锁的实现方案有哪些？哪些方案更常用？\n- **答案**：\n\n  - 自己实现简单的分布式锁（如基于 `setnx`）。\n  - 使用成熟的库，如 **Redisson**。\n  - 红锁机制（少用）。","outline":"- **锁的定义与特点**  \n- **Redis setnx 实现互斥**  \n- **锁无法释放的解决方案**  \n- **锁过期问题与看门狗机制**  \n- **看门狗线程与业务线程关系**  \n- **分布式锁的可重入性实现**  \n- **分布式锁的阻塞机制**  \n- **Redis 主从架构下的锁丢失**  \n- **解决主从锁丢失的方法**  \n- **联锁与红锁机制对比**  \n- **红锁机制的问题与局限**  \n- **常见分布式锁实现方案**","categories":[{"id":5,"name":"Redis","level":1,"sortOrder":0,"createTime":"2025-07-11T23:57:15.075663","updateTime":"2025-07-11T23:57:15.075686","fullPath":"Redis","topLevel":true},{"id":6,"name":"分布式锁","level":2,"sortOrder":0,"createTime":"2025-07-11T23:57:23.999653","updateTime":"2025-07-11T23:57:23.999661","fullPath":"Redis > 分布式锁","topLevel":false}],"createdAt":"2025-07-06T22:53:00.656901","updatedAt":"2025-07-12T23:16:38.099542"},{"id":2,"title":"Redisson（一）","content":"![image.png](https://image-1322336011.cos.ap-shanghai.myqcloud.com/20231118210633.png)\n\n# 1. 加锁和解锁\n- **Lua脚本保证原子性**：加锁和解锁均通过Lua脚本实现，确保操作（检查锁存在性、更新计数器、设置超时）的原子性。\n  - **加锁脚本**：检查锁是否存在，不存在则创建并设置超时；存在则验证是否为当前线程持有，是则重入。\n  - **解锁脚本**：校验锁归属，计数器减1后若归零则删除锁，并发布解锁消息。\n\n## 为什么要用lua脚本呢？\n```lua\nif ((redis.call('exists', KEYS[1]) == 0) \n    or (redis.call('hexists', KEYS[1], ARGV[2]) == 1)) then \n    redis.call('hincrby', KEYS[1], ARGV[2], 1); \n    redis.call('pexpire', KEYS[1], ARGV[1]); \n    return nil; \nend; \nreturn redis.call('pttl', KEYS[1]);\n```\n这个 Lua 脚本实现了以下逻辑：\n1. **检查锁是否已存在**：\n    - 如果锁不存在（`exists KEYS[1] == 0`），或者锁已存在且是当前线程持有（`hexists KEYS[1], ARGV[2] == 1`），则执行加锁。\n2. **加锁操作**：\n    - 增加锁的重入次数：`hincrby KEYS[1], ARGV[2], 1`。\n    - 设置锁的过期时间：`pexpire KEYS[1], ARGV[1]`。\n3. **返回锁的剩余 TTL**：\n    - 如果锁未被当前线程持有，返回锁的剩余时间（TTL），以便客户端知道需要等待多长时间。\n\n**为什么用 Lua 脚本加锁？**\n- **支持可重入锁**：Lua 脚本可以直接操作 Redis 的 `Hash` 数据结构，允许同一个线程多次获取同一个锁。\n- **原子性**：Lua 脚本在 Redis 服务端一次性执行，避免了多个命令之间的竞争条件问题。\n- **扩展性**：可以轻松添加其他逻辑，比如记录锁的持有线程、设置锁的自动续期等。\n\n## 扩展问题：为什么lua脚本可以保证原子性？\n![image.png](https://image-1322336011.cos.ap-shanghai.myqcloud.com/202312162239786.png)\n\n# 2. Watch Dog自动延期机制（看门狗机制）\n**自动续期防止锁超时**：若未显式指定锁超时时间（如`lock.lock()`），Redisson默认启动看门狗线程，每10秒（默认）续期锁至30秒，避免业务未完成时锁超时释放\n\n# 3. 可重入加锁机制\n#### **可重入锁机制**\n- **Hash结构存储锁信息**：Redisson使用Redis的Hash结构存储锁，Key为锁名称（如`xxl:job:时间戳`），Field为客户端唯一标识（`UUID + 线程ID`），Value为重入计数器。\n  - **示例**：同一线程多次调用`lock()`时，计数器自增；`unlock()`时计数器自减，归零后删除锁\n  - **代码优化建议**：若业务存在嵌套锁场景（如递归调用），需确保`lock()`和`unlock()`成对出现。\n\n# 4. **锁竞争与重试机制**\n- **发布订阅模式**：当锁被其他线程持有时，当前线程订阅解锁消息通道，避免轮询消耗资源；收到解锁通知后重新竞争锁\n  - **可重试逻辑**：通过`tryLock()`方法支持设置最大等待时间（`waitTime`），实现阻塞式或非阻塞式重试\n\n# 5. Redisson实现公平锁\n\n1. **什么是公平锁？**\n\n    保证等待最久的线程最先获取锁\n\n2. **Redisson的公平锁是如何实现的？**\n\n（1）Redisson的公平锁是通过有序集合（zset）实现的。每个锁都对应一个有序集合(zset)，集合中的成员是等待锁的线程，分数是线程的等待时间戳。获取锁时，Redisson会将线程添加到有序集合中，并按照时间戳排序。（当前线程如果不是在最前面，则需要等待），排在zset最前面的线程获取到锁\n\n（3）当释放锁时，Redisson 会从有序集合中移除当前线程的标识，并通过 publish 通知其他线程锁已释放。等待时间最长的线程会在接收到通知后重新尝试获取锁(检查自己是否是zset的第一个成员，如果是，则获取锁；如果不是，则继续等待)，从而实现公平性。\n\n3. **是怎么通知其他线程的？**\n\n    使用的Redis的publish命令，也就是发布订阅的能力（`publish` 命令会将消息广播给所有订阅了该频道的客户端）\n\n```lua\nredis.call('publish', KEYS[2], ARGV[2]);\nKEYS[2] 是锁对应的频道名称。\nARGV[2] 是通知的内容，通常是一个简单的消息，表明锁已释放。\n```","outline":"**知识要点提示大纲**\n\n1. **加锁与解锁机制**  \n   - Lua脚本实现原子性  \n   - 加锁逻辑与重入处理  \n   - 解锁验证与消息通知  \n\n2. **Lua脚本优势**  \n   - 可重入支持  \n   - 原子性保障  \n   - 扩展性强  \n\n3. **看门狗自动延期**  \n   - 自动续期机制  \n   - 防止锁过早释放  \n\n4. **可重入锁实现**  \n   - Hash结构存储信息  \n   - 重入计数器管理  \n   - 成对调用建议  \n\n5. **锁竞争与重试**  \n   - 发布订阅避免轮询  \n   - tryLock重试逻辑  \n\n6. **公平锁实现**  \n   - 有序集合（zset）管理等待队列  \n   - 获取锁顺序控制  \n   - 释放锁后通知机制","categories":[{"id":5,"name":"Redis","level":1,"sortOrder":0,"createTime":"2025-07-11T23:57:15.075663","updateTime":"2025-07-11T23:57:15.075686","fullPath":"Redis","topLevel":true},{"id":6,"name":"分布式锁","level":2,"sortOrder":0,"createTime":"2025-07-11T23:57:23.999653","updateTime":"2025-07-11T23:57:23.999661","fullPath":"Redis > 分布式锁","topLevel":false}],"createdAt":"2025-07-08T23:00:39.224842","updatedAt":"2025-07-12T23:16:22.582084"},{"id":4,"title":"Redisson（二）","content":"# 4. **锁竞争与重试机制**\n\n`lock()方法`：（无返回值）`lock()` 方法是阻塞获取锁的方式，如果当前锁被其他线程持有，则当前线程会一直阻塞等待获取锁，直到获取到锁或者发生超时或中断等情况才会结束等待\n\n```java\nlock.lock()  // 阻塞时获取锁\nlock.lock(30, TimeUnit.SECONDS); // 尝试获取锁，30秒后自动释放\n```\n\n\n\n## 非阻塞获取锁\n\n`tryLock()方法`：（有返回值）`tryLock()` 方法是一种非阻塞获取锁的方式，在尝试获取锁时不会阻塞当前线程，而是立即返回获取锁的结果，如果获取成功则返回 true，否则返回 false（可以设置 **等待时间**（`waitTime`）和 **锁持有时间**（`leaseTime`），灵活控制锁的获取和持有行为）\n\n```java\n// 不阻塞，立即获取结果\nboolean success = lock.tryLock()\n\n// 尝试获取锁，等待最多 5 秒，成功后持有锁 10 秒\nboolean success = lock.tryLock(5, 10, TimeUnit.SECONDS);\n```\n\n## 发布订阅模式\n\n**锁释放后的竞争**：\n\n- 当锁被释放时，Redisson 会通知等待队列中的线程。\n- 如果是公平锁（`RedissonFairLock`），线程会按照队列顺序竞争锁。\n- 如果是普通锁（`RedissonLock`），竞争顺序可能不是严格的 FIFO（先到先得）。\n\n是如何通知的？\n\n- 使用的Redis的publish命令，也就是发布订阅的能力（`publish` 命令会将消息广播给所有订阅了该频道的客户端，收到解锁通知后重新竞争锁）\n\n\n# 5. Redisson实现公平锁\n\n1. **什么是公平锁？**\n\n    保证等待最久的线程最先获取锁\n\n2. **Redisson的公平锁是如何实现的？**\n\n（1）Redisson的公平锁是通过有序集合（zset）实现的。每个锁都对应一个有序集合(zset)，集合中的成员是等待锁的线程，分数是线程的等待时间戳。获取锁时，Redisson会将线程添加到有序集合中，并按照时间戳排序。（当前线程如果不是在最前面，则需要等待），排在zset最前面的线程获取到锁\n\n（3）当释放锁时，Redisson 会从有序集合中移除当前线程的标识，并通过 publish 通知其他线程锁已释放。等待时间最长的线程会在接收到通知后重新尝试获取锁(检查自己是否是zset的第一个成员，如果是，则获取锁；如果不是，则继续等待)，从而实现公平性。\n\n3. **是怎么通知其他线程的？**\n\n    使用的Redis的publish命令，也就是发布订阅的能力（`publish` 命令会将消息广播给所有订阅了该频道的客户端）\n\n```lua\nredis.call('publish', KEYS[2], ARGV[2]);\nKEYS[2] 是锁对应的频道名称。\nARGV[2] 是通知的内容，通常是一个简单的消息，表明锁已释放。\n```","outline":"**知识要点提示大纲**\n\n- **锁竞争与重试机制**\n  - lock() 方法\n  - tryLock() 方法\n  - 非阻塞获取锁\n  - 等待时间与持有时间设置\n\n- **发布订阅模式**\n  - 锁释放后的竞争机制\n  - 公平锁与普通锁的区别\n  - Redis 的 publish 命令作用\n\n- **Redisson 公平锁实现**\n  - 公平锁定义\n  - zset 数据结构应用\n  - 获取锁流程\n  - 释放锁流程\n  - Redis 发布订阅通知机制","categories":[{"id":5,"name":"Redis","level":1,"sortOrder":0,"createTime":"2025-07-11T23:57:15.075663","updateTime":"2025-07-11T23:57:15.075686","fullPath":"Redis","topLevel":true},{"id":6,"name":"分布式锁","level":2,"sortOrder":0,"createTime":"2025-07-11T23:57:23.999653","updateTime":"2025-07-11T23:57:23.999661","fullPath":"Redis > 分布式锁","topLevel":false}],"createdAt":"2025-07-11T23:14:53.785471","updatedAt":"2025-07-12T23:16:10.492789"},{"id":10,"title":"Redisson（三）","content":"# 6. Redisson的联锁\n\n## 6.1. 什么是联锁？\n\n    支持同时获取多个锁，防止死锁\n\n## 6.2. 代码\n\n    ```java\n    RLock lock1 = redisson.getLock(\"lock1\");\n    RLock lock2 = redisson.getLock(\"lock2\");\n    RLock lock3 = redisson.getLock(\"lock3\");\n    // 创建联锁\n    RLock multiLock = redisson.getMultiLock(lock1, lock2, lock3);\n    // 加锁\n    multiLock.lock();  或者  multiLock.tryLock(10, 30, TimeUnit.SECONDS);（添加超时时间）\n\n    try {\n        // 执行需要同时锁定多个资源的操作\n        System.out.println(\"所有锁已成功获取\");\n    } finally {\n        // 释放锁\n        multiLock.unlock();\n    }\n    ```\n\n## 6.3. 使用场景\n\n    1. 订单和库存的联合操作\n\n        > 在电商系统中，创建订单时需要同时锁定订单记录和库存记录，以防止其他线程或服务修改数据。例如：\n        >\n        > - 线程 A 锁定订单 `order:123` 和库存 `stock:456`。\n        > - 线程 B 锁定订单 `order:124` 和库存 `stock:456`。 通过联锁，可以确保操作的原子性，避免死锁。\n        >\n\n## 6.4. 避免死锁的机制\n\n    1. **统一获取所有锁**：\n\n        - 只有当所有锁都成功获取时，线程才会持有联锁。\n        - 如果某个锁获取失败，会自动释放之前已获取的锁。\n    2. **严格的加锁顺序**：\n\n        - 联锁内部会按照一定的顺序尝试获取锁，确保多个线程在获取相同资源时遵循相同的顺序，从而避免死锁。\n    3. **超时机制**：\n\n        - 联锁支持设置获取锁的超时时间。如果线程无法在指定时间内获取所有锁，会主动放弃并释放已获取的锁。\n\n## 6.5. 联锁机制的问题\n联锁机制可能因为某个主节点网络延迟或宕机导致加锁失败，整体加锁成功率较低。解决方案是：可以优化为红锁机制，只需半数以上节点加锁成功即可\n\n\n# 7. 红锁\n\n## 7.1 红锁的实现\n\n我们使用RRedLock来创建一个红锁对象，然后使用redLock.tryLock()来尝试获取锁。如果大多数节点成功获取锁，就会执行锁保护的代码。\n\n```java\nRLock lock1 = redisson.getLock(\"lock1\");\nRLock lock2 = redisson.getLock(\"lock2\");\nRLock lock3 = redisson.getLock(\"lock3\");\nRLock redLock = redisson.getRedLock(lock1, lock2, lock3);\nboolean isLocked = redLock.tryLock(100, 60, TimeUnit.SECONDS);\n```\n\n\n## 7.2 Redisson红锁解决了什么问题\n\n- 红锁设计的初衷是解决**单点 Redis 实例锁不可靠的问题**，尤其是在 Redis 主从复制延迟或故障时，传统锁可能失效，导致并发控制失败。\n- Redisson 红锁通过**多个 Redis 实例获取多数节点锁**，提高了锁的可靠性和容错性。\n\n\n## 7.3 Redisson红锁的问题：\n\n**问题一：时间同步问题**\n\n> 客户端在每个 Redis 实例上设置锁时，会指定一个统一的超时时间。如果 Redis 实例的时间不一致（如某个节点的时间快或慢），可能导致某些节点上的锁比预期时间提前过期、某些节点上的锁比预期时间晚过期。（如果提前释放锁，可能导致其他客户端错误获取锁，引起并发问题；如果晚释放，导致新客户端无法获取锁，影响系统的性能和可用性）\n\n```java\n举例：\n假设有 3 个 Redis 节点，客户端在每个节点上设置锁的超时时间为 10 秒：\n\nRedis 节点 A 的时间比真实时间快 2 秒。\nRedis 节点 B 的时间是正确的。\nRedis 节点 C 的时间比真实时间慢 3 秒。\n锁的行为可能如下：\n\n节点 A 在 8 秒后认为锁已经过期。\n节点 B 在 10 秒后认为锁已经过期。\n节点 C 在 13 秒后认为锁才过期。\n```\n\n解决方案：\n\n1. **时间同步机制**\n\n    - 使用 NTP（Network Time Protocol，网络时间协议）对所有 Redis 实例的时间进行同步，确保每个节点的时间保持一致。\n    - 定期检查和修复时间偏差，避免时间漂移。\n2. **相对时间代替绝对时间**\n\n    - 在实现分布式锁时，尽量使用相对时间（如锁的存活时间计时从当前时刻开始）而不是依赖绝对时间。\n    - Redisson 内部通过 Redis 的 `PEXPIRE` 命令设置锁的超时时间，使用的是相对时间，因此在一定程度上缓解了时间同步问题。\n3. **增加锁的冗余机制**\n\n    - 即使时间同步出现问题，可以通过增加锁的数量（更多的 Redis 节点）来提高容错性。\n\n\n扩展问题：\n\n> Redisson 在加锁时将你传入的 `leaseTime`（如 10 秒）转换为毫秒数（10,000），作为相对时间参数传给 Redis 的 `PEXPIRE` 命令。这个时间是**从 Redis 当前时刻算起**的，所以即便系统时间不同步，也能保证各节点锁超时逻辑一致。\n\n\t\n\n问题二：**网络分区导致的一致性问题**\n\n在网络分区的情况下，可能会出现多个客户端在不同的网络分区中同时获得锁，从而破坏锁的互斥性，导致数据一致性问题。\n\n1. **锁的双重获取**\n\n    - 假设有 5 个 Redis 节点，其中 3 个节点属于网络分区 A，另 2 个节点属于网络分区 B。\n    - 如果客户端 1 在分区 A 中获取了锁，并在 A 的 3 个节点上成功加锁；\n    - 同时，客户端 2 在分区 B 中也可以获取锁，因为 B 中的 2 个节点与 A 中的节点无法通信，客户端 2 无法感知锁的存在。\n    - 结果：客户端 1 和客户端 2 都认为自己获取了锁，导致锁的互斥性被破坏。\n2. **锁释放的不一致**\n\n    - 如果客户端在某些节点上成功加锁，但在锁释放时，由于网络分区，无法释放其他节点上的锁，导致锁的状态不一致。\n    - 其他客户端可能无法正确获取锁，影响系统的可用性。\n\n#### **示例**\n\n假设有 5 个 Redis 节点，客户端 1 和客户端 2 试图同时获取锁：\n\n- 正常情况下：\n\n  - 客户端 1 在 3 个节点上成功加锁（多数派），锁获取成功。\n  - 客户端 2 加锁失败。\n- 网络分区情况下：\n\n  - 分区 A：包含 3 个节点，客户端 1 在分区 A 上成功加锁。\n  - 分区 B：包含 2 个节点，客户端 2 在分区 B 上也成功加锁。\n  - 结果：客户端 1 和客户端 2 都认为自己持有锁，导致数据一致性问题。\n\n### **解决方法**\n\n- **减少网络分区**：通过优化网络基础设施，减少分区发生的概率。\n- **使用一致性协议**：红锁并不保证严格一致性。如果业务对一致性要求极高，考虑使用基于共识协议（如 Paxos、Raft）的锁机制，如 ZooKeeper 或 etcd。\n- **多层锁保护机制**：在本地 JVM 或数据库层再加一层锁，形成“防护网”\n\n\n# 8. 读写锁\n\nRedisson支持读写锁，允许**多个线程同时读取共享资源，但只允许一个线程写入资源**。这在某些场景下可以提高性能\n\n使用RReadWriteLock来创建一个读写锁对象，并分别使用readLock和writeLock来获取读锁和写锁。这样，可以实现多个线程同时读取资源，但只有一个线程能够写入资源\n\n```java\nRReadWriteLock rwLock = redisson.getReadWriteLock(\"myReadWriteLock\");\nRLock readLock = rwLock.readLock();\nRLock writeLock = rwLock.writeLock();\n\n// 获取读锁\nreadLock.lock();\ntry {\n    // 执行读操作\n} finally {\n    readLock.unlock();\n}\n\n// 获取写锁\nwriteLock.lock();\ntry {\n    // 执行写操作\n} finally {\n    writeLock.unlock();\n}\n```","outline":"### 知识要点提示大纲（简洁版）\n\n- **6. Redisson 联锁**\n  - 联锁定义\n  - 联锁代码实现\n  - 使用场景\n  - 避免死锁机制\n  - 联锁问题与优化\n\n- **7. 红锁**\n  - 红锁实现方式\n  - 红锁解决的问题\n  - 红锁存在的问题\n  - 时间同步问题\n  - 网络分区问题\n  - 解决方案\n\n- **8. 读写锁**\n  - 读写锁功能\n  - 读锁与写锁使用\n  - 读写锁代码示例","categories":[{"id":5,"name":"Redis","level":1,"sortOrder":0,"createTime":"2025-07-11T23:57:15.075663","updateTime":"2025-07-11T23:57:15.075686","fullPath":"Redis","topLevel":true},{"id":6,"name":"分布式锁","level":2,"sortOrder":0,"createTime":"2025-07-11T23:57:23.999653","updateTime":"2025-07-11T23:57:23.999661","fullPath":"Redis > 分布式锁","topLevel":false}],"createdAt":"2025-07-12T08:43:08.040932","updatedAt":"2025-07-12T23:15:59.775871"},{"id":12,"title":"Redis主从同步锁丢失问题","content":"# 1. 主从同步-锁丢失问题\n问题1：redis主从架构时，主节点写入了一个分布式锁，再同步到从节点的时候发生了故障，导致这个分布式锁未成功同步到从节点，这个时候从节点被选举为主节点，分布式锁的业务还未执行完毕，这个时候另一个线程就可以获取到锁，这样就导致业务被并发执行了，如何解决这个问题？\n\n问题2：Redis 主从架构下锁丢失问题怎么解决？\n\n以上两个问题类似，答案是可以使用联锁或者红锁（但都有各自的问题），或者使用zookeeper、etcd\n\n- 联锁机制：Redis 部署多主或多主多从，加锁时必须所有主节点都成功加锁才算加锁成功。\n- 红锁机制：Redis 部署多个主节点，只需要半数以上节点加锁成功即可。\n\n## 1.1 联锁的问题\n联锁机制可能因为某个主节点网络延迟或宕机导致加锁失败，整体加锁成功率较低。可以优化为红锁机制，只需半数以上节点加锁成功即可。\n\n## 1.2 红锁的问题\n（1）时间同步问题，不同节点的系统时钟可能不一致，导致时间严格要求出现问题。\n（2）并发安全性问题：当客户端加锁时，如果遇到 GC 可能会导致加锁失效，但 GC 后误认为加锁成功的安全事故\n（3）多主节点的运维复杂，数据一致性难以保证。\n原因：红锁机制虽然理论上很强，但实现复杂，且运维成本高，实际中并不常用。\n\n### 1.2.1 GC暂停线程导致加锁的事故问题（这点举个例子）\n 1. 客户端 A 请求 3 个节点进行加锁。\n 2. 在节点回复处理之前，客户端 A 进入 GC 阶段（存在 STW，全局停顿）。\n 3. 之后因为加锁时间的原因，锁已经失效了。\n 4. 客户端 B 请求加锁（和客户端 A 是同一把锁），加锁成功。\n 5. 客户端 A GC 完成，继续处理前面节点的消息，误以为加锁成功。\n 6. 此时客户端 B 和客户端 A 同时加锁成功，出现并发安全性问题。\n\n### 1.2.2 时钟同步问题举个例子（网络问题）\n![](https://image-1322336011.cos.ap-shanghai.myqcloud.com/202507122257322.png)\n\n### 1.2.3 关于网络问题可以再举个例子（网络分区问题）\n![](https://image-1322336011.cos.ap-shanghai.myqcloud.com/202507122258595.png)","outline":"### 知识要点大纲（提示回忆用）\n\n- **主从同步-锁丢失问题**\n  - 联锁机制\n  - 红锁机制\n  - 其他方案：ZooKeeper、etcd\n\n- **联锁的问题**\n  - 加锁成功率低\n  - 网络或节点故障影响整体加锁\n\n- **红锁的问题**\n  - 时间同步问题\n  - GC 导致加锁失效风险\n  - 多主节点运维复杂\n  - 数据一致性难保证\n\n- **红锁事故案例**\n  - GC 暂停导致误加锁\n  - 时钟不同步引发问题\n  - 网络分区影响加锁过程","categories":[{"id":5,"name":"Redis","level":1,"sortOrder":0,"createTime":"2025-07-11T23:57:15.075663","updateTime":"2025-07-11T23:57:15.075686","fullPath":"Redis","topLevel":true},{"id":6,"name":"分布式锁","level":2,"sortOrder":0,"createTime":"2025-07-11T23:57:23.999653","updateTime":"2025-07-11T23:57:23.999661","fullPath":"Redis > 分布式锁","topLevel":false}],"createdAt":"2025-07-12T22:53:26.744631","updatedAt":"2025-07-12T23:13:15.037089"}],"level":2,"sortOrder":0,"knowledgeCount":5,"name":"分布式锁","id":6},{"knowledgeSet":[{"id":13,"title":"主从复制","content":"# 1. 主从复制的断点续传（增量复制）\n\n- 什么是断点续传：从redis2.8开始，就支持主从复制的断点续传，如果主从复制的过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头复制\n- 核心原理：master node会在内存中保存一个backlog。master和slave都会保存一个replica offset和master id，offset就是保存在backlog中。如果master和slave网络连接断掉了，slave会让master从上次的replica offset开始复制，但是如果没有找到对应的offset,就会执行一次resynchronization\n\n# 2. slave节点过期key是如何处理的\n\nslave不会过期key,只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key,那么会模拟一条del命令发送给slave\n\n# 3. 心跳机制\n\n在Redis主从复制架构中，Redis使用心跳机制来检测主节点和从节点之间的连接状态。这个心跳机制主要包括两个方面：PING命令和复制偏移量。\n\n1. PING命令：主节点会周期性地向从节点发送PING命令，以确认从节点是否在线。从节点收到PING命令后会回复一个PONG响应，表示自己仍然存活。如果主节点在一定时间内没有收到从节点的PONG响应，就会认为从节点宕机或者与从节点的连接出现问题。\n2. 复制积压缓冲区（replication backlog）：主节点会将自己的数据更新发送给从节点，并存储在复制积压缓冲区中。从节点会定期向主节点报告自己的复制偏移量，主节点通过比较从节点的复制偏移量和自己的复制偏移量来判断从节点是否与主节点保持同步。如果从节点的复制偏移量长时间没有更新，主节点会认为从节点与自己的连接出现问题。\n\n## 3.1 扩展：如果通过心跳机制发现了从节点的不可用，主节点会做什么呢？\n\n当主节点通过心跳机制发现从节点可能出现了不可用的情况时，它可以采取以下几种措施：\n\n1. 重新选择从节点：如果主节点发现当前的从节点不可用，它可以重新选择一个可用的从节点来替代它。主节点会从备选的从节点列表中选择一个新的从节点，并将其设置为新的复制目标。这样可以确保主节点始终有可用的从节点进行数据复制和故障恢复。\n2. 进行故障恢复：如果主节点发现从节点不可用，并且没有其他可用的从节点可以替代，它可以尝试进行故障恢复。故障恢复的过程包括重新同步数据和重新选举主节点。\n\n    - 重新同步数据：主节点可以将自己的数据重新发送给从节点，使其与主节点的数据保持一致。这可以通过将复制积压缓冲区中的数据重新发送给从节点来实现。重新同步数据可能会导致一定的网络和系统负载，因此需要谨慎使用。\n    - 重新选举主节点：如果主节点发现从节点不可用，并且没有其他可用的从节点可以替代，它可以尝试进行重新选举主节点的过程。重新选举主节点需要从备选的从节点中选择一个新的主节点，并进行相应的配置和数据同步操作。\n\n# 4. 主从复制的核心原理\n\n![image.png](https://image-1322336011.cos.ap-shanghai.myqcloud.com/202312162244342.png)","outline":"- 1. 主从复制的断点续传  \n- 2. Slave节点过期Key处理  \n- 3. 心跳机制与故障应对  \n- 4. 主从复制核心原理","categories":[{"id":5,"name":"Redis","level":1,"sortOrder":0,"createTime":"2025-07-11T23:57:15.075663","updateTime":"2025-07-11T23:57:15.075686","fullPath":"Redis","topLevel":true},{"id":13,"name":"架构","level":1,"sortOrder":0,"createTime":"2025-07-12T22:19:08.628868","updateTime":"2025-07-12T22:19:08.628872","fullPath":"Redis > 架构","topLevel":false}],"createdAt":"2025-07-12T23:07:25.063231","updatedAt":"2025-07-12T23:07:25.06324"}],"level":1,"sortOrder":0,"knowledgeCount":1,"name":"架构","id":13}],"sortOrder":0,"knowledgeCount":6,"name":"Redis","id":5},{"knowledgeSet":[],"level":1,"sortOrder":0,"knowledgeCount":0,"name":"MySQL","id":12},{"knowledgeSet":[],"level":1,"children":[{"knowledgeSet":[],"level":2,"sortOrder":1,"knowledgeCount":0,"name":"测试子分类","id":14},{"knowledgeSet":[],"level":2,"sortOrder":1,"knowledgeCount":0,"name":"测试子分类","id":15}],"sortOrder":1,"knowledgeCount":0,"name":"Java","id":1}]}